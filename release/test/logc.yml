envs:
  dev:
    <<: *defaults
  demo:
    <<: *defaults
  qa:
    <<: *defaults
  production:
    <<: *defaults

defaults: &defaults
  name: test
  mailer: mailer://smtp.qq.com:25/?user=小美<xiaomei-go@qq.com>&pass=zjsbosjlhgugechh
  keepers: [  ]
  batch:
    size: 102400 # how many bytes to read once
    wait: 3s     # how long to wait to full fill batch.size
  rotate:
    time: "33 8 1 * * *" # cron time pattern to execute rotate.cmd
    cmd:  [ logrotate, logrotate.conf ]
  files:
    -
      # file path, required, either relative or absolute is ok.
      path: app.log
      outputs:
        - "@type": elastic-search
          addrs:
            - http://log-es.com/logc-dev-

          # index can be time series index or regular index.
          # time series index, string between "<" and ">" acts as layout.
          # see https://golang.org/pkg/time/#Parse for layout format.
          # index doesn't contain "<" and ">" acts as a regular index.
          index: app-<2006.01.02>

          # the number of latest time series indices to keep. old indices will be deleted.
          # effective only when "index" field is a time series index.
          indexKeep: 3

          type: app-log
          mapping: *mapping
          timeField: at
          # time layout to parse "timeField". (default: RFC3339)
          timeFormat: "2006-01-02T15:04:05Z0700"
    - path: app.err
      outputs:
        - "@type": elastic-search
          addrs:
            - http://log-es.com/logc-dev-
          index: app-<2006.01.02>-err
          type: app-err
          mapping: *mapping
          timeField: at
          timeFormat: "2006-01-02T15:04:05Z0700"
    - path: consume.log
      outputs:
        - "@type": elastic-search
          addrs:
            - http://log-es.com/logc-dev-
          index: test-consume
          type: consume-log
          mapping: *mappingConsume
          timeField: at

mapping: &mapping
  at: { type: date }
  duration: { type: float }
  host: { type: keyword }
  method: { type: keyword }
  path: { type: text, fields: { raw: { type: keyword } }}
  query: { type: text }
  status: { type: keyword }
  req_body: { type: integer }
  res_body: { type: integer }
  ip: { type: ip }
  refer: { type: text }
  agent: { type: text }
  proto: { type: keyword }
  # session: sess

mappingConsume: &mappingConsume
  at: { type: date }
  data: { type: object }
